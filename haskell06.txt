
You are on page 8of 24
 
What are types? How are they used?basic types and how to combine themfunction types in detailconcepts of polymorphism and type classes3.1 Basic Conceptsa type is a collection (set?) of related values.e.g: The type Bool contains the two values True and Falsee.g: The type Bool -> Bool has as values all functions that take a boolean argument and return a boolean. for example, the function notNotation - v :: T = v is a value in type T = value v has type Te.g: False :: Boolnot :: Bool -> Bool The symbol :: can also be used with values that have not been evaluated in which case e :: T is interpreted as 'when e is evaluated a value v of type T results'e.g: not False :: Boolnot True :: Bool not (not False) :: BoolIn Haskell, every expression must have a type, which is evaluated before the expression is evaluated. The calculation of the type is called 'type inference'Typing rule for function application. f :: A -> B, e :: A / f e :: BExpressions such as 'not 3' which do not have a type/for which a type cannot be inferred are said to contain a 'type error' and are deemed to be invalid expressions.Because type inference preceeds evaluation, Haskell programs are 'type safe' == type errors can't happen during evaluation, and this eradicates large classes of errors.however 1 `div` 0 will still evaluate to an error though it is well typed.:t 1 `div` 01 `div` 0 :: Integral a => a3.2 Basic Typesprovided by Haskell - Bool: logical values. True, False - Char: single characters. contains all single characters in the Unicode system, the international standard for representing text based information,including all normal English letters, a number of control characters (e.g '\n'). - String: strings of characters - "abc", "" (the empty string) - Int: fixed precision integers. For GHC range -2^63 to 2^63 -1. Going outside this range gives unexpected results. - Integer: arbitrary precision integers - integers with no upper or lower limits but memory of the system - Float: single precision floating point numbers
 
 - Double: Double precision floating point numbersA single number may have more than one numeric type.e.g 3 can have type Int, Integer, Float, or double.This raises the question of what type these numbers should be assigned during type inference. This is dealt with later, when we consider type classes.3.3 List TypesA list is a sequence of elements of the same typee.g: [False,True,False] :: [Bool]length of a list = number of elements in the list*Main> length [1,2,3]3Emptylist [] :: [t] The type of a list conveys no information about its lengthThere is no restriction about the type of elements in a list. We can have lists of lists, lists of functions, lists of lists of functions etcThere is no restriction that a list should have a finite length. With the use of lazy evaluation, lists of inifinite lengths are natural and practical3.4 Tuple TypesA tuple is a *finite* sequence of components of *possibly different types*, with the components being enclosed in round parentheses, and separated by commas.For tuples with i-th components having type T_i, we write the type as (T_1, T_2, T_3 ... )so (False,True) :: (Bool,Bool)(False, 'a',True) :: (Bool, Char, Bool) etcthe number of components in a tuple is called its arity.Empty tuple () :: ()Tuples of arity 1 such as (False) are not permitted.The type (Bool, Char) contains all pairs (tuples of arity 2) with a first component of type Bool and a second component of type CharThere are no restrictions on the type of tuples. We can have tuples of lists of functions etcTuples must have finite arity. This ensures that tuple types can be inferred prior to evaluation.3.5 Function TypesA function is a mapping from arguments of one type to the result of another type. T1 -> T2 is the type of all functions that take arguments of type T1 and return results of type T2e.g: not :: Bool -> Bool(key insight) since there are no restrictions on the types of the arguments and the results of a function, the notion of a function with a single argument and a single result is sufficient to handle functions with multiple arguments and res
 
ults, by packaging multiple values into lists or tuples.e.g: a function add that adds up a pair of integersadd :: (Int, Int) -> Intadd (x,y) = x + ye.g: a function that returns a list of numbers from 0 to nzeroTo :: Int -> [Int]zeroTo n = [0..n]There is no restriction that functions must be total. There maybe some arguments for which the result is not defined.> head []** Exception blah blah ..**3.6 Curried FunctionsFunctions with multiple arguments can be handled in another way.Consideradd' :: Int -> (Int -> Int)add' x y = x + yThe type states that add' is a function that takes an integer and returns a *function* that takes an integer and returns an integerThe definition states that add' takes an integer x and returns a function that in turn takes an integer y and returns x + y.Note: add produces the same result as add'. But add takes two arguments at the same time, packaged as a pair, where add' takes two arguments, one at a time. The types reflect this.Functions like add' are called curried functions. They are more flexible than function on tuples, because(key point) useful functions can often be made by ***partially applying*** curried functions with less than a full complement of arguments.e.g a function that increments its argument by one can be created by add' 1Some conventions and associations.The 'function arrow' in types associates to the rightso Int -> Int -> Int is really Int -> (Int -> Int)Consequently function application associates to the leftmult x y z is really (((mult x) y) z)Unless tupling is explicitly required, multi argument functions in Haskell are curried. Later we'll see how curried functions can be formalized using lambda expressions.3.7 Polymorphic TypesThe library function length calculates the length of any list irrespective of content type.
 
*Main> :t lengthlength :: Foldable t => t a -> IntThe idea that length can work with lists whose elements have any type is made precise in its type declaration by using a type variablelength :: [a] -> inti.e for any type a, (a is a type variable) length has type [a] -> IntThe values of this variable are types like Int, Bool, Bool->Bool or whatever.A type that contains one or more type variables is polymorphic.So [a] -> Int is a polymorphic type and length is a polymorphic function.Many of the functions provided in the standard prelude are polymorphic.Eg.head :: [a] -> Inttake :: Int -> [a] -> [a]zip :: [a] -> [b] -> [(a,b)]id :: a -> a3.8 Overloaded TypesThe arithmetic operator + calculates the sum of any two numbers of the same numeric type.It can be used to calculate the sum of two integers, or the sum of two floating point numbers.> 1 + 2 => 3> 1.0 + 2.0 => 3.0(key) the idea that + can be applied to numbers of any type is made clear by using a class constraint.Class constraints are written in the form C a where C is a class and a is a type variableFor example the type of the addition operator + is as follows(+) :: Num a => a -> a -> aThat is for any type a that is an *instance* of the (type)class Num, the function + has the type a -> a -> a(Parethesizing an operator converts it into a curried function, as we'll see in Chapter 6A type that contains one or more class constraints is called an overloaded type. A function with a type signature that contains a class constraint, i.e has an overloaded type , is an overloaded function.e.g:(+) :: Num a => a -> a -> anegate :: Num a => a -> a -> aNumbers themselves are overloaded3 :: Num a => a means that for any numeric type a, 3 has type ain this manner, 3 could be an integer, a floating point number, or more generally a value of any numeric type depending on the context of use
 
3.9 Basic ClassesA type is a collection of related valuesA class is a collection of types that support certain overloaded operations called *methods*Haskell provides a number of built in types of which the most common are described belowe. (More advanced built in classes are considered in part 2) 1. Eq - Equality Types This class contains types whose values can be compared for equality and inequality using the following two methods (==) :: a -> a -> Bool (/=) :: a -> a -> Bool All basic types Bool, Char, String, Int, Integer, Float and Double are instances of the Eq class as are list and tuple types *provided* that their element and component types are instances.E.g: False == False => True'a' == 'b' => False"abc" == "abc" => True[1,2)] == [1,2,3] => False('a',False) == ('a',False) =. TrueNote: Function types are in general *not* members of the Eq class because in general function(value)S cannot be compared for equality. 2. Ord - Ordered types instances of the typeclass Eq but in addition whose values are linearly ordered, and can be compared using the following six methods (<) :: a -> a -> Bool (<=) :: a -> a -> Bool (>) :: a -> a -> Bool (>=) :: a -> a -> Bool min :: a -> a -> Bool max :: a -> a -> Bool All basic types - Int, Integer, Bool, Char, String, Float, and Double are instances of the Ord typeclass, as are list and tuple types as long as their element/component types are instances .e.g:False < Ture => Truemin 'a' 'b' => 'a'"elegant" < "elephant" => True[1,2,3] < [1,2] => False('a',2) < ('b', 1) => TrueStrings, lists and tuples are ordered lexicographically 3. Show - showable types This class contains types whose values can be converted into strings using the following methoh show :: a -> StringAll basic types - Int, Integer, Float, Double, Char, String, are instances of the Show class, as are list and tuple types provided their element/component types are instances.
Recommended Documents
Documents Similar To Study Notes on Graham Hutton's Haskell Book (2nd edition)

    document
    NetLogo Tyler Lee
    document
    GLSL Specificacion 1.20.8
    document
    Graphical User Interfaces in Haskell
    document
    CLAD Add on for Workshop 2
    document
    Interface Cat Service
    document
    Chisel Manual
    document
    Chap04 Conditional
    document
    Create OAM of HBC087
    document
    Java Methods Retur Values
    document
    LRM
    document
    Scientiﬁc Computation and Functional Programming
    document
    apr10certsd
    document
    C Sharp
    document
    Stat133AllLectures
    document
    Standard ECMA 262
    document
    Javascript
    document
    's Melodien (Article)
    document
    CSC128 Chapter 2 - Basic Elements of Computer Programs
    document
    An Introduction to Pandas
    document
    Hibernate
    document
    Introduction to functional programming
    document
    Pemrograman Haskell
    document
    Algorithms and Data Structures
    document
    106819450-MQL-for-Traders.pdf
    document
    Howto Clinic
    document
    Alv Sample Codes
    document
    Interview 5
    document
    CPP 1 Corrected)
    document
    CSC148_Mid_2010F
    document
    CLLE400

Documents About Boolean Data Type

    document
    Mastek_Sample_Programming_Placement_Paper_Level1
    document
    Microsoft v Motorola ITC '376 Patent Claim Chart
    document
    tmp4AFB
    document
    Ness Technologies Sample Programmingy Placement Paper Level1

More From magesmail7563

    document
    Ten a Dons Questions
    document
    Lenormand 1 Thru 6
    document
    Study Notes
    document
    Morin Lilly Notes
    document
    Morin Notes 1
    document
    Chart Analysis Record
    document
    Notes on Solar Returns Book
    document
    Notes for Hutton's book
    document
    Analysis of an event chart
    document
    Happy Tracks commentary on David Coleman's shamanistic astrology article
    document
    Notes on Ben Dykes Astrology book
    document
    notes on Ben Dykes astrology text
    document
    Apocalypse World Cheat Sheet
    document
    Concrete Maths Notes 1
    document
    Dykes Traditional
    document
    Supplemental material for The 26 Keys
    document
    Alchemy Forum
    document
    Major planets transits for 1972 - 2032
    document
    The 26 Keys Practice Manual 1
    document
    Beat Krummenacher - Spagyric Tinctures
    document
    notes on bertekas text
    document
    Hamlet Hit Points notes
    document
    Westeros based rpg notes
    document
    Rpg City Build
    document
    Newport's stretch churn concept
    document
    Brandon Sanderson Writing Class
    document
    Notes on Jim Butcher's Writing Advise
    document
    Study Notes on Bell's Plot and Structure
    document
    Notes on Thiels startup notions

Footer Menu
About

    About Scribd
    Press
    Our blog
    Join our team!
    Contact Us
    Join today
    Invite Friends
    Gifts

Legal

    Terms
    Privacy
    Copyright

Support

    Help / FAQ
    Accessibility
    Purchase help
    AdChoices
    Publishers

Social Media
Copyright © 2017 Scribd Inc. .Browse Books.Mobile Site.Site Directory.Site Language:
